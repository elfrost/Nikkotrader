"""
Master Agent - Orchestrateur principal du syst√®me NIKKOTRADER V11
Utilise CrewAI pour coordonner tous les agents sp√©cialis√©s
"""

import asyncio
import json
import logging
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

from crewai import Agent, Task, Crew, Process
from langchain.llms import OpenAI
from langchain.tools import BaseTool
import redis.asyncio as redis
from loguru import logger

from shared.config import AgentConfig
from shared.redis_manager import RedisManager
from shared.models import TradingSignal, AgentStatus, SystemEvent
from shared.metrics import MetricsExporter

@dataclass
class AgentTask:
    """Repr√©sente une t√¢che assign√©e √† un agent"""
    id: str
    agent_name: str
    task_type: str
    priority: int
    data: Dict[str, Any]
    created_at: datetime
    status: str = "pending"

class MasterAgent:
    """
    Agent Master - Orchestrateur principal du syst√®me
    Coordonne tous les agents sp√©cialis√©s et prend les d√©cisions finales
    """
    
    def __init__(self, config: AgentConfig):
        self.config = config
        self.redis_manager = RedisManager()
        self.agent_name = "MasterAgent"
        self.status = "stopped"
        self.heartbeat_interval = 30
        
        # Agents sp√©cialis√©s
        self.specialized_agents = {}
        self.active_tasks = {}
        self.signal_queue = []
        
        # M√©triques
        self.total_decisions = 0
        self.successful_decisions = 0
        self.failed_decisions = 0
        
        # Configuration CrewAI
        self.crew = None
        self.setup_crew()
        
        # Initialisation des m√©triques Prometheus
        self.metrics = MetricsExporter(self.agent_name, "master", 8080)
        
        logger.info(f"üéØ {self.agent_name} initialis√©")
    
    def setup_crew(self):
        """Configuration de l'√©quipe CrewAI"""
        
        # Agent principal de d√©cision
        decision_agent = Agent(
            role="Trading Decision Coordinator",
            goal="Coordonner les d√©cisions de trading en analysant les signaux de tous les agents sp√©cialis√©s",
            backstory="""
            Je suis l'orchestrateur principal d'un syst√®me de trading algorithmique multi-agents.
            Ma mission est de collecter les signaux de tous les agents sp√©cialis√©s,
            d'analyser leur qualit√© et leur coh√©rence, puis de prendre les d√©cisions finales
            pour maximiser les performances tout en minimisant les risques.
            """,
            verbose=True,
            allow_delegation=False
        )
        
        # Agent de gestion des risques
        risk_agent = Agent(
            role="Risk Management Specialist",
            goal="√âvaluer et filtrer les signaux selon les crit√®res de risque d√©finis",
            backstory="""
            Je suis sp√©cialis√© dans l'analyse des risques. J'√©value chaque signal
            selon les crit√®res de drawdown, corr√©lation, et exposition.
            Je peux rejeter des signaux qui ne respectent pas les limites de risque.
            """,
            verbose=True,
            allow_delegation=False
        )
        
        # Agent de performance
        performance_agent = Agent(
            role="Performance Analyst",
            goal="Analyser les performances historiques pour optimiser les d√©cisions futures",
            backstory="""
            J'analyse en continu les performances des strat√©gies et des agents.
            J'identifie les patterns de succ√®s et d'√©chec pour am√©liorer
            les crit√®res de d√©cision et l'allocation des ressources.
            """,
            verbose=True,
            allow_delegation=False
        )
        
        # Cr√©er l'√©quipe
        self.crew = Crew(
            agents=[decision_agent, risk_agent, performance_agent],
            tasks=[],  # Les t√¢ches seront ajout√©es dynamiquement
            verbose=True,
            process=Process.sequential
        )
    
    async def start(self):
        """D√©marrage du Master Agent"""
        logger.info(f"üöÄ D√©marrage du {self.agent_name}")
        
        self.status = "running"
        
        # D√©marrer le serveur de m√©triques Prometheus
        self.metrics.start_server()
        
        # Mettre √† jour le statut dans Redis
        await self.redis_manager.set_agent_status(self.agent_name, {
            "status": "running",
            "last_heartbeat": datetime.now(timezone.utc).isoformat(),
            "total_tasks": self.total_decisions,
            "successful_tasks": self.successful_decisions,
            "failed_tasks": self.failed_decisions
        })
        
        # D√©marrer les t√¢ches principales
        await asyncio.gather(
            self.heartbeat_loop(),
            self.signal_processing_loop(),
            self.agent_monitoring_loop(),
            self.decision_making_loop()
        )
    
    async def stop(self):
        """Arr√™t du Master Agent"""
        logger.info(f"üõë Arr√™t du {self.agent_name}")
        
        self.status = "stopped"
        
        # Mettre √† jour le statut dans Redis
        await self.redis_manager.set_agent_status(self.agent_name, {
            "status": "stopped",
            "last_heartbeat": datetime.now(timezone.utc).isoformat()
        })
    
    async def heartbeat_loop(self):
        """Boucle de heartbeat pour indiquer que l'agent est vivant"""
        while self.status == "running":
            try:
                # Mettre √† jour Redis
                await self.redis_manager.set_agent_status(self.agent_name, {
                    "status": "running",
                    "last_heartbeat": datetime.now(timezone.utc).isoformat(),
                    "total_tasks": self.total_decisions,
                    "successful_tasks": self.successful_decisions,
                    "failed_tasks": self.failed_decisions
                })
                
                # Mettre √† jour les m√©triques Prometheus
                self.metrics.update_heartbeat()
                self.metrics.update_performance(
                    daily_pnl=0,  # √Ä calculer selon vos donn√©es
                    win_rate=self.successful_decisions / max(self.total_decisions, 1),
                    active_trades=len(self.active_tasks),
                    drawdown=0  # √Ä calculer selon vos donn√©es
                )
                
                await asyncio.sleep(self.heartbeat_interval)
                
            except Exception as e:
                logger.error(f"‚ùå Erreur dans heartbeat: {str(e)}")
                self.metrics.record_task("failed")
                await asyncio.sleep(5)
    
    async def signal_processing_loop(self):
        """Boucle de traitement des signaux entrants"""
        while self.status == "running":
            try:
                # √âcouter les signaux des agents sp√©cialis√©s
                signals = await self.redis_manager.get_pending_signals()
                
                for signal in signals:
                    await self.process_signal(signal)
                
                await asyncio.sleep(1)  # V√©rification toutes les secondes
                
            except Exception as e:
                logger.error(f"‚ùå Erreur dans signal processing: {str(e)}")
                await asyncio.sleep(5)
    
    async def agent_monitoring_loop(self):
        """Surveillance des agents sp√©cialis√©s"""
        while self.status == "running":
            try:
                # V√©rifier l'√©tat de tous les agents
                agents_status = await self.redis_manager.get_all_agents_status()
                
                for agent_name, status in agents_status.items():
                    if agent_name != self.agent_name:
                        await self.check_agent_health(agent_name, status)
                
                await asyncio.sleep(30)  # V√©rification toutes les 30 secondes
                
            except Exception as e:
                logger.error(f"‚ùå Erreur dans agent monitoring: {str(e)}")
                await asyncio.sleep(10)
    
    async def decision_making_loop(self):
        """Boucle de prise de d√©cision principale"""
        while self.status == "running":
            try:
                # Traiter la queue des signaux
                if self.signal_queue:
                    signals_batch = self.signal_queue[:10]  # Traiter par batch de 10
                    self.signal_queue = self.signal_queue[10:]
                    
                    decision = await self.make_trading_decision(signals_batch)
                    
                    if decision:
                        await self.execute_decision(decision)
                
                await asyncio.sleep(5)  # D√©cisions toutes les 5 secondes
                
            except Exception as e:
                logger.error(f"‚ùå Erreur dans decision making: {str(e)}")
                await asyncio.sleep(10)
    
    async def process_signal(self, signal: Dict[str, Any]):
        """Traiter un signal entrant"""
        try:
            logger.info(f"üìä Traitement du signal: {signal['symbol']} - {signal['strategy']}")
            
            # Ajouter le signal √† la queue pour traitement
            self.signal_queue.append(signal)
            
            # Mettre √† jour les m√©triques
            self.total_decisions += 1
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du traitement du signal: {str(e)}")
            self.failed_decisions += 1
    
    async def make_trading_decision(self, signals: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """Prendre une d√©cision de trading bas√©e sur les signaux"""
        try:
            if not signals:
                return None
            
            # Cr√©er une t√¢che pour l'√©quipe CrewAI
            decision_task = Task(
                description=f"""
                Analyser les signaux de trading suivants et prendre une d√©cision:
                {json.dumps(signals, indent=2)}
                
                Crit√®res √† √©valuer:
                1. Qualit√© des signaux (confiance, coh√©rence)
                2. Risque/rendement
                3. Corr√©lations entre paires
                4. Conditions de march√© actuelles
                5. Limites de risque
                
                Retourner une d√©cision structur√©e avec:
                - Action recommand√©e (EXECUTE, REJECT, WAIT)
                - Signaux s√©lectionn√©s
                - Justification
                - Score de confiance
                """,
                agent=self.crew.agents[0]
            )
            
            # Ex√©cuter la t√¢che
            result = self.crew.kickoff([decision_task])
            
            # Parser le r√©sultat
            decision = await self.parse_crew_decision(result)
            
            if decision and decision.get("action") == "EXECUTE":
                self.successful_decisions += 1
                return decision
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la prise de d√©cision: {str(e)}")
            self.failed_decisions += 1
            return None
    
    async def parse_crew_decision(self, crew_result: Any) -> Optional[Dict[str, Any]]:
        """Parser le r√©sultat de l'√©quipe CrewAI"""
        try:
            # Extraire la d√©cision du r√©sultat CrewAI
            # (Impl√©mentation sp√©cifique selon le format de retour)
            
            return {
                "action": "EXECUTE",
                "signals": [],
                "justification": "Test decision",
                "confidence": 0.75,
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du parsing de la d√©cision: {str(e)}")
            return None
    
    async def execute_decision(self, decision: Dict[str, Any]):
        """Ex√©cuter une d√©cision de trading"""
        try:
            logger.info(f"üéØ Ex√©cution de la d√©cision: {decision['action']}")
            
            # Publier la d√©cision pour les autres agents
            await self.redis_manager.publish_decision(decision)
            
            # Enregistrer l'√©v√©nement
            await self.redis_manager.log_system_event({
                "event_type": "trading.decision_executed",
                "agent": self.agent_name,
                "decision": decision,
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de l'ex√©cution de la d√©cision: {str(e)}")
    
    async def check_agent_health(self, agent_name: str, status: Dict[str, Any]):
        """V√©rifier la sant√© d'un agent sp√©cialis√©"""
        try:
            last_heartbeat = datetime.fromisoformat(status.get("last_heartbeat", "1970-01-01T00:00:00+00:00"))
            time_since_heartbeat = (datetime.now(timezone.utc) - last_heartbeat).total_seconds()
            
            if time_since_heartbeat > 60:  # Plus de 1 minute sans heartbeat
                logger.warning(f"‚ö†Ô∏è Agent {agent_name} n'a pas donn√© signe de vie depuis {time_since_heartbeat}s")
                
                # Essayer de red√©marrer l'agent
                await self.restart_agent(agent_name)
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la v√©rification de l'agent {agent_name}: {str(e)}")
    
    async def restart_agent(self, agent_name: str):
        """Red√©marrer un agent d√©faillant"""
        try:
            logger.info(f"üîÑ Red√©marrage de l'agent {agent_name}")
            
            # Envoyer un signal de red√©marrage
            await self.redis_manager.send_agent_command(agent_name, {
                "command": "restart",
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du red√©marrage de l'agent {agent_name}: {str(e)}")

# Point d'entr√©e principal
async def main():
    """Point d'entr√©e principal du Master Agent"""
    
    # Configuration
    config = AgentConfig(
        name="MasterAgent",
        type="master",
        redis_url="redis://localhost:6379",
        max_concurrent_tasks=10,
        heartbeat_interval=30
    )
    
    # Cr√©er et d√©marrer le Master Agent
    master = MasterAgent(config)
    
    try:
        await master.start()
    except KeyboardInterrupt:
        logger.info("üõë Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        logger.error(f"‚ùå Erreur critique: {str(e)}")
    finally:
        await master.stop()

if __name__ == "__main__":
    asyncio.run(main()) 